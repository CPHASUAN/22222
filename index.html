<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AI è£ç½®ç«¯æ‰‹å‹¢åˆ‡æ°´æœ (HandPose æœ€çµ‚ä¿®æ­£ç‰ˆ)</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.13.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/handpose@0.0.7/dist/handpose.min.js"></script>
    
    <style>
        /* ------------------- CSS ä¿æŒä¸è®Š ------------------- */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #000;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            max-width: 600px;
            max-height: 900px;
            margin: auto;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #video, #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #video {
            opacity: 0.2;
            transform: scaleX(-1); /* å‰é¡é ­é è¨­é¡åƒ */
        }

        #canvas {
            z-index: 10;
        }

        #status {
            position: absolute;
            top: 10px;
            width: 80%;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.9);
            color: #333;
            border-radius: 8px;
            font-weight: bold;
            z-index: 20;
            text-align: center;
        }

        #start-btn {
            position: absolute;
            bottom: 50px;
            background-color: #e91e63;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 30px;
            font-size: 1.2em;
            cursor: pointer;
            z-index: 30;
            transition: background-color 0.3s;
        }

        #start-btn:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <video id="video" autoplay muted playsinline></video>
        <canvas id="canvas"></canvas>

        <div id="status">æ­£åœ¨è¼‰å…¥ AI æ¨¡å‹...</div>
        <button id="start-btn" disabled>ç­‰å¾…æ¨¡å‹è¼‰å…¥...</button>
    </div>

    <script>
        /* ------------------- JavaScript Start ------------------- */

        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const statusDiv = document.getElementById('status');
        const startBtn = document.getElementById('start-btn');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('game-container');
        
        let detector = null; 
        let animationFrameId = null;
        let isRunning = false;
        
        // åº§æ¨™è¨ˆç®—åƒæ•¸ (ç”± loadeddata äº‹ä»¶è¨­ç½®)
        let scaleRatio = 1;
        let startX = 0;
        let startY = 0;

        // åµæ¸¬é»æ­·å²
        const fingerHistory = [];
        const HISTORY_LENGTH = 5; 

        // HandPose é—œéµé»ç´¢å¼•ï¼šé£ŸæŒ‡æŒ‡å°–
        // HandPose çš„é—œéµé»åç¨±æ˜¯ 'indexFingerTip'ï¼Œç´¢å¼•æ˜¯ 8ã€‚
        const INDEX_FINGER_TIP = 8; 

        const FRUITS = ['ğŸ', 'ğŸ‰', 'ğŸ¥', 'ğŸ‹', 'ğŸ‡'];
        let activeFruits = [];
        let score = 0;

        const FRUIT_SIZE = 50;
        let lastLaunchTime = 0;
        const LAUNCH_INTERVAL = 1500;

        // --- 1. æ ¸å¿ƒæ¨¡å‹å’Œå•Ÿå‹• (ä¿®æ­£ HandPose è¼‰å…¥) ---

        async function loadModelsAndStart() {
            try {
                statusDiv.innerHTML = "æ­£åœ¨è¼‰å…¥ HandPose æ¨¡å‹... (å„ªåŒ–æ‰‹éƒ¨è¿½è¹¤)";
                startBtn.disabled = true;

                // **ä¿®æ­£è¼‰å…¥é…ç½®ï¼šç¢ºä¿ç©©å®šæ€§**
                detector = await handpose.load({
                    detectionConfidence: 0.8, // æé«˜åµæ¸¬ä¿¡å¿ƒé–¾å€¼
                    maxContinuousChecks: 10   // å¢åŠ è¿½è¹¤ç©©å®šæ€§
                }); 

                statusDiv.innerHTML = "âœ… æ¨¡å‹è¼‰å…¥å®Œæˆï¼ç¾åœ¨å¯åˆ‡æ›è‡³é£›èˆªæ¨¡å¼é‹è¡Œã€‚";
                statusDiv.style.backgroundColor = 'rgba(0, 128, 0, 0.8)';
                startBtn.disabled = false;
                startBtn.textContent = "é–‹å§‹åˆ‡æ°´æœï¼";
                
                startCamera();

            } catch (error) {
                console.error("è¼‰å…¥æ¨¡å‹å¤±æ•—:", error);
                statusDiv.innerHTML = `âŒ æ¨¡å‹è¼‰å…¥å¤±æ•—ï¼Œè«‹æª¢æŸ¥ç¶²è·¯é€£ç·šã€‚éŒ¯èª¤: ${error.message}`;
                statusDiv.style.backgroundColor = 'rgba(255, 0, 0, 0.8)';
            }
        }
        
        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        facingMode: 'user', 
                        width: { ideal: 640 }, 
                        height: { ideal: 480 } 
                    } 
                });
                video.srcObject = stream;
                // ç¢ºä¿å½±ç‰‡é–‹å§‹æ’­æ”¾å¾Œå†èª¿æ•´å°ºå¯¸
                video.addEventListener('loadeddata', handleVideoLoadedData);
            } catch (err) {
                console.error("ç„¡æ³•å–å¾—ç›¸æ©Ÿæ¬Šé™:", err);
                statusDiv.innerHTML = "âŒ ç„¡æ³•å•Ÿå‹•ç›¸æ©Ÿï¼Œè«‹æª¢æŸ¥æ¬Šé™ã€‚";
            }
        }
        
        // å°‡åº§æ¨™è¨ˆç®—é‚è¼¯ç¨ç«‹å‡ºä¾†
        function handleVideoLoadedData() {
            video.removeEventListener('loadeddata', handleVideoLoadedData);

            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            
            canvas.width = containerWidth;
            canvas.height = containerHeight;

            const ratio = Math.max(containerWidth / video.videoWidth, containerHeight / video.videoHeight);
            scaleRatio = ratio;
            
            const effectiveWidth = video.videoWidth * ratio;
            const effectiveHeight = video.videoHeight * ratio;

            startX = (containerWidth - effectiveWidth) / 2;
            startY = (containerHeight - effectiveHeight) / 2;

            // ç”±æ–¼ CSS transform: scaleX(-1) (é¡åƒ)ï¼Œèª¿æ•´ X è»¸çš„èµ·å§‹é»
            startX = containerWidth - startX - effectiveWidth;
        }


        // --- 2. æ°´æœç‰©ä»¶èˆ‡ç”Ÿæˆ (ä¿æŒä¸è®Š) ---

        class Fruit {
            constructor(emoji) {
                this.emoji = emoji;
                this.x = Math.random() * (canvas.width * 0.8) + (canvas.width * 0.1);
                this.y = canvas.height + FRUIT_SIZE;
                this.radius = FRUIT_SIZE / 2;
                this.velocity = { 
                    x: (Math.random() - 0.5) * 5,
                    y: - (Math.random() * 10 + 20)
                };
                this.gravity = 0.9;
                this.isCut = false;
                this.cutAngle = 0;
            }

            update() {
                this.velocity.y += this.gravity;
                this.x += this.velocity.x;
                this.y += this.velocity.y;
            }

            draw() {
                ctx.font = `${FRUIT_SIZE}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                if (this.isCut) {
                    const halfText = this.emoji.substring(0, 1);
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.cutAngle);
                    ctx.fillText(halfText, -this.radius / 2, 0); 
                    ctx.fillText(halfText, this.radius / 2, 0);
                    ctx.restore();
                } else {
                    ctx.fillText(this.emoji, this.x, this.y);
                }
            }
        }

        function launchFruit(timestamp) {
            if (timestamp - lastLaunchTime > LAUNCH_INTERVAL) {
                const randomEmoji = FRUITS[Math.floor(Math.random() * FRUITS.length)];
                activeFruits.push(new Fruit(randomEmoji));
                lastLaunchTime = timestamp;
            }
        }


        // --- 3. AI åµæ¸¬èˆ‡åˆ‡ä¸­é‚è¼¯ ---

        function checkCollision(history, fruit) {
            if (fruit.isCut) return false;
            if (history.length < 2) return false;

            const p1 = history[history.length - 1];
            const p2 = history[history.length - 2];

            const dist = Math.hypot(p1.x - fruit.x, p1.y - fruit.y);

            if (dist < fruit.radius * 1.5) { 
                fruit.isCut = true;
                fruit.cutAngle = Math.atan2(p2.y - p1.y, p2.x - p1.x); 
                
                score++;
                statusDiv.innerHTML = `å¾—åˆ†ï¼š${score} | æˆåŠŸåˆ‡ä¸­ ${fruit.emoji}`;
                return true;
            }
            return false;
        }

        async function detectAndGameLoop(timestamp) {
            if (!detector || video.paused || video.ended || !isRunning) {
                cancelAnimationFrame(animationFrameId);
                return;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 1. åŸ·è¡Œ AI åµæ¸¬
            const predictions = await detector.estimateHands(video);

            if (predictions && predictions.length > 0) {
                const hand = predictions[0];
                // **ä¿®æ­£ï¼šHandPose è¼¸å‡ºçš„æ˜¯ keypoints é™£åˆ—ï¼Œç›´æ¥å–ç´¢å¼•**
                const fingerTipCoords = hand.landmarks[INDEX_FINGER_TIP]; 
                
                // ä¿®æ­£å¾Œçš„æ˜ å°„å‡½å¼ï¼šè™•ç† HandPose è¼¸å‡ºé™£åˆ—
                const mapKeypoint = (kp) => {
                    // kp[0] æ˜¯ x, kp[1] æ˜¯ y
                    const flippedX = video.videoWidth - kp[0];

                    return {
                        x: flippedX * scaleRatio + startX, 
                        y: kp[1] * scaleRatio + startY
                    };
                };

                // æ›´æ–°æŒ‡å°–è»Œè·¡
                const mappedTip = mapKeypoint(fingerTipCoords);
                fingerHistory.push(mappedTip);
                if (fingerHistory.length > HISTORY_LENGTH) fingerHistory.shift();
                
                // ç¹ªè£½æŒ‡å°–è»Œè·¡
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 10;
                ctx.lineCap = 'round';
                ctx.beginPath();
                fingerHistory.forEach((p, index) => {
                    if (index === 0) {
                        ctx.moveTo(p.x, p.y);
                    } else {
                        ctx.lineTo(p.x, p.y);
                    }
                });
                ctx.stroke();

                // 2. éŠæˆ²é‚è¼¯ï¼šåˆ‡ä¸­åˆ¤æ–·
                activeFruits.forEach(fruit => {
                    if (!fruit.isCut) {
                        checkCollision(fingerHistory, fruit);
                    }
                });

            } else {
                // å¦‚æœæ²’æœ‰åµæ¸¬åˆ°æ‰‹éƒ¨ï¼Œæ¸…ç©ºè»Œè·¡
                fingerHistory.length = 0; 
            }

            // 3. æ›´æ–°èˆ‡ç¹ªè£½æ°´æœ
            launchFruit(timestamp);

            activeFruits.forEach(fruit => {
                fruit.update();
                fruit.draw();
            });

            activeFruits = activeFruits.filter(fruit => fruit.y > -FRUIT_SIZE);

            animationFrameId = requestAnimationFrame(detectAndGameLoop);
        }

        // --- 4. äº‹ä»¶ç›£è½å™¨èˆ‡åˆå§‹åŒ– ---

        startBtn.addEventListener('click', () => {
             if (!isRunning) {
                 isRunning = true;
                 startBtn.textContent = "éŠæˆ²é€²è¡Œä¸­...";
                 startBtn.disabled = true;
                 score = 0;
                 activeFruits = [];
                 fingerHistory.length = 0; 
                 lastLaunchTime = 0;
                 statusDiv.innerHTML = `å¾—åˆ†ï¼š0 | è«‹å°‡é£ŸæŒ‡å°æº–é¡é ­ï¼`;
                 detectAndGameLoop(performance.now());
             }
        });
        
        loadModelsAndStart(); 

        /* ------------------- JavaScript End ------------------- */
    </script>
</body>
</html>
