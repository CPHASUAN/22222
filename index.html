<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AI è£ç½®ç«¯æ‰‹å‹¢åˆ‡æ°´æœ (MoveNet)</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.13.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.0.0/dist/pose-detection.min.js"></script>
    
    <style>
        /* ------------------- CSS Start ------------------- */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #000;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            max-width: 600px;
            max-height: 900px;
            margin: auto;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #video, #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover; /* é—œéµï¼šç¢ºä¿å½±ç‰‡å¡«æ»¿å®¹å™¨ä¸¦å¯èƒ½è¢«è£å‰ª */
        }

        #video {
            opacity: 0.2;
            transform: scaleX(-1); /* å‰é¡é ­é è¨­é¡åƒ */
        }

        #canvas {
            z-index: 10;
        }

        #status {
            position: absolute;
            top: 10px;
            width: 80%;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.9);
            color: #333;
            border-radius: 8px;
            font-weight: bold;
            z-index: 20;
            text-align: center;
        }

        #start-btn {
            position: absolute;
            bottom: 50px;
            background-color: #e91e63;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 30px;
            font-size: 1.2em;
            cursor: pointer;
            z-index: 30;
            transition: background-color 0.3s;
        }

        #start-btn:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        /* ------------------- CSS End ------------------- */
    </style>
</head>
<body>

    <div id="game-container">
        <video id="video" autoplay muted playsinline></video>
        <canvas id="canvas"></canvas>

        <div id="status">æ­£åœ¨è¼‰å…¥ AI æ¨¡å‹...</div>
        <button id="start-btn" disabled>ç­‰å¾…æ¨¡å‹è¼‰å…¥...</button>
    </div>

    <script>
        /* ------------------- JavaScript Start ------------------- */

        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const statusDiv = document.getElementById('status');
        const startBtn = document.getElementById('start-btn');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('game-container');
        
        let detector = null;
        let animationFrameId = null;
        let isRunning = false;
        
        // **ä¿®æ­£å¾Œåº§æ¨™è¨ˆç®—åƒæ•¸**
        let scaleRatio = 1;
        let startX = 0;
        let startY = 0;

        const handHistory = { left: [], right: [] };
        const HISTORY_LENGTH = 5;

        const FRUITS = ['ğŸ', 'ğŸ‰', 'ğŸ¥', 'ğŸ‹', 'ğŸ‡'];
        let activeFruits = [];
        let score = 0;

        const FRUIT_SIZE = 50;
        let lastLaunchTime = 0;
        const LAUNCH_INTERVAL = 1500;

        // --- 1. æ ¸å¿ƒæ¨¡å‹å’Œå•Ÿå‹• (ä¿®æ­£ MoveNetType éŒ¯èª¤) ---

        async function loadModelsAndStart() {
            try {
                statusDiv.innerHTML = "æ­£åœ¨è¼‰å…¥ MoveNet æ¨¡å‹... (è¼•é‡ç´š SinglePose.Lightning)";
                startBtn.disabled = true;

                // **ä¿®æ­£ MoveNet é…ç½®ï¼šç›´æ¥ä½¿ç”¨å­—ä¸²å®šç¾©æ¨¡å‹ç‰ˆæœ¬**
                const detectorParams = {
                    modelType: 'SinglePose.Lightning', 
                    enableSmoothing: true
                };
                
                detector = await poseDetection.createDetector(
                    poseDetection.SupportedModels.MoveNet,
                    detectorParams
                );

                statusDiv.innerHTML = "âœ… æ¨¡å‹è¼‰å…¥å®Œæˆï¼ç¾åœ¨å¯åˆ‡æ›è‡³é£›èˆªæ¨¡å¼é‹è¡Œã€‚";
                statusDiv.style.backgroundColor = 'rgba(0, 128, 0, 0.8)';
                startBtn.disabled = false;
                startBtn.textContent = "é–‹å§‹åˆ‡æ°´æœï¼";
                
                startCamera();

            } catch (error) {
                console.error("è¼‰å…¥æ¨¡å‹å¤±æ•—:", error);
                statusDiv.innerHTML = `âŒ æ¨¡å‹è¼‰å…¥å¤±æ•—ï¼ŒéŒ¯èª¤: ${error.message}`;
                statusDiv.style.backgroundColor = 'rgba(255, 0, 0, 0.8)';
            }
        }
        
        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        facingMode: 'user', 
                        width: { ideal: 640 }, 
                        height: { ideal: 480 } 
                    } 
                });
                video.srcObject = stream;
            } catch (err) {
                console.error("ç„¡æ³•å–å¾—ç›¸æ©Ÿæ¬Šé™:", err);
                statusDiv.innerHTML = "âŒ ç„¡æ³•å•Ÿå‹•ç›¸æ©Ÿï¼Œè«‹æª¢æŸ¥æ¬Šé™ã€‚";
            }
        }

        // å½±ç‰‡è¼‰å…¥å®Œæˆå¾Œï¼ŒåŸ·è¡Œåº§æ¨™è¨ˆç®— (ä¿®æ­£ object-fit: cover è£å‰ªå•é¡Œ)
        video.addEventListener('loadeddata', () => {
            const videoRatio = video.videoWidth / video.videoHeight;
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            const containerRatio = containerWidth / containerHeight;

            canvas.width = containerWidth;
            canvas.height = containerHeight;

            // è¨ˆç®—å¯¦éš›çš„ç¸®æ”¾æ¯”ç‡
            const ratio = Math.max(containerWidth / video.videoWidth, containerHeight / video.videoHeight);
            scaleRatio = ratio;
            
            const effectiveWidth = video.videoWidth * ratio;
            const effectiveHeight = video.videoHeight * ratio;

            // è¨ˆç®—åç§»é‡ (Gutter)
            startX = (containerWidth - effectiveWidth) / 2;
            startY = (containerHeight - effectiveHeight) / 2;

            // ç”±æ–¼ CSS transform: scaleX(-1) (é¡åƒ)ï¼Œæˆ‘å€‘éœ€è¦èª¿æ•´ X è»¸çš„èµ·å§‹é»ã€‚
            // é¡åƒæœƒå°‡ AI è¼¸å‡ºçš„ X è»¸åŸé» (0) æ˜ å°„åˆ°é¡¯ç¤ºå€åŸŸçš„å³å´ã€‚
            // æˆ‘å€‘å°‡ startX è¨­ç‚ºå¾å³é‚Šé–‹å§‹çš„åç§»é‡ã€‚
            startX = containerWidth - startX - effectiveWidth;
        });


        // --- 2. æ°´æœç‰©ä»¶èˆ‡ç”Ÿæˆ ---

        class Fruit {
            constructor(emoji) {
                this.emoji = emoji;
                this.x = Math.random() * (canvas.width * 0.8) + (canvas.width * 0.1);
                this.y = canvas.height + FRUIT_SIZE;
                this.radius = FRUIT_SIZE / 2;
                this.velocity = { 
                    x: (Math.random() - 0.5) * 5,
                    y: - (Math.random() * 10 + 20)
                };
                this.gravity = 0.9;
                this.isCut = false;
                this.cutAngle = 0;
            }

            update() {
                this.velocity.y += this.gravity;
                this.x += this.velocity.x;
                this.y += this.velocity.y;
            }

            draw() {
                ctx.font = `${FRUIT_SIZE}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                if (this.isCut) {
                    const halfText = this.emoji.substring(0, 1);
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.cutAngle);
                    ctx.fillText(halfText, -this.radius / 2, 0); 
                    ctx.fillText(halfText, this.radius / 2, 0);
                    ctx.restore();
                } else {
                    ctx.fillText(this.emoji, this.x, this.y);
                }
            }
        }

        function launchFruit(timestamp) {
            if (timestamp - lastLaunchTime > LAUNCH_INTERVAL) {
                const randomEmoji = FRUITS[Math.floor(Math.random() * FRUITS.length)];
                activeFruits.push(new Fruit(randomEmoji));
                lastLaunchTime = timestamp;
            }
        }


        // --- 3. AI åµæ¸¬èˆ‡åˆ‡ä¸­é‚è¼¯ ---

        function checkCollision(history, fruit) {
            if (fruit.isCut) return false;
            if (history.length < 2) return false;

            const p1 = history[history.length - 1];
            const p2 = history[history.length - 2];

            // åˆ¤æ–·ç•¶å‰æ‰‹éƒ¨ä½ç½®èˆ‡æ°´æœä¸­å¿ƒé»çš„è·é›¢
            const dist = Math.hypot(p1.x - fruit.x, p1.y - fruit.y);

            if (dist < fruit.radius * 1.5) { // æé«˜åµæ¸¬ç¯„åœ
                fruit.isCut = true;
                // ä½¿ç”¨æ‰‹éƒ¨ç§»å‹•æ–¹å‘ä½œç‚ºåˆ‡å£è§’åº¦
                fruit.cutAngle = Math.atan2(p2.y - p1.y, p2.x - p1.x); 
                
                score++;
                statusDiv.innerHTML = `å¾—åˆ†ï¼š${score} | æˆåŠŸåˆ‡ä¸­ ${fruit.emoji}`;
                return true;
            }
            return false;
        }

        async function detectAndGameLoop(timestamp) {
            if (!detector || video.paused || video.ended || !isRunning) {
                cancelAnimationFrame(animationFrameId);
                return;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 1. åŸ·è¡Œ AI åµæ¸¬
            const poses = await detector.estimatePoses(video, {
                // AI è¼¸å‡ºåº§æ¨™æ™‚ä¸é€²è¡Œç¿»è½‰ï¼Œè®“ AI è¼¸å‡ºç¶­æŒåœ¨éé¡åƒåº§æ¨™ç³»
                flipHorizontal: false 
            });

            if (poses && poses.length > 0) {
                const pose = poses[0];
                const keypoints = pose.keypoints;
                
                const leftWrist = keypoints[9];
                const rightWrist = keypoints[10];
                
                // **ä¿®æ­£å¾Œçš„æ˜ å°„å‡½å¼**ï¼šæ‡‰ç”¨ç¸®æ”¾ã€å¹³ç§»å’Œé¡åƒ
                const mapKeypoint = (kp) => {
                    // 1. é¡åƒè™•ç†ï¼šå› ç‚º CSS é¡åƒäº†ï¼Œæ‰€ä»¥ AI è¼¸å‡ºçš„ X è»¸éœ€è¦åè½‰ (video.videoWidth - kp.x)
                    const flippedX = video.videoWidth - kp.x;

                    return {
                        x: flippedX * scaleRatio + startX, // æ‡‰ç”¨é¡åƒã€ç¸®æ”¾ã€Xè»¸åç§»
                        y: kp.y * scaleRatio + startY      // æ‡‰ç”¨ç¸®æ”¾ã€Yè»¸åç§»
                    };
                };

                // æ›´æ–°æ‰‹éƒ¨è»Œè·¡
                if (leftWrist.score > 0.6) {
                    handHistory.left.push(mapKeypoint(leftWrist));
                    if (handHistory.left.length > HISTORY_LENGTH) handHistory.left.shift();
                }
                if (rightWrist.score > 0.6) {
                    handHistory.right.push(mapKeypoint(rightWrist));
                    if (handHistory.right.length > HISTORY_LENGTH) handHistory.right.shift();
                }
                
                // ç¹ªè£½æ‰‹éƒ¨è»Œè·¡
                [handHistory.left, handHistory.right].forEach(history => {
                    ctx.strokeStyle = 'cyan';
                    ctx.lineWidth = 8;
                    ctx.beginPath();
                    history.forEach((p, index) => {
                        if (index === 0) {
                            ctx.moveTo(p.x, p.y);
                        } else {
                            ctx.lineTo(p.x, p.y);
                        }
                    });
                    ctx.stroke();
                });
                
                // 2. éŠæˆ²é‚è¼¯ï¼šåˆ‡ä¸­åˆ¤æ–·
                activeFruits.forEach(fruit => {
                    if (!fruit.isCut) {
                        checkCollision(handHistory.left, fruit) || checkCollision(handHistory.right, fruit);
                    }
                });

            }

            // 3. æ›´æ–°èˆ‡ç¹ªè£½æ°´æœ
            launchFruit(timestamp);

            activeFruits.forEach(fruit => {
                fruit.update();
                fruit.draw();
            });

            activeFruits = activeFruits.filter(fruit => fruit.y > -FRUIT_SIZE);

            animationFrameId = requestAnimationFrame(detectAndGameLoop);
        }

        // --- 4. äº‹ä»¶ç›£è½å™¨èˆ‡åˆå§‹åŒ– ---

        startBtn.addEventListener('click', () => {
             if (!isRunning) {
                 isRunning = true;
                 startBtn.textContent = "éŠæˆ²é€²è¡Œä¸­...";
                 startBtn.disabled = true;
                 score = 0;
                 activeFruits = [];
                 handHistory.left = [];
                 handHistory.right = [];
                 lastLaunchTime = 0;
                 statusDiv.innerHTML = `å¾—åˆ†ï¼š0 | è«‹æ®å‹•æ‚¨çš„æ‰‹ï¼`;
                 detectAndGameLoop(performance.now());
             }
        });
        
        loadModelsAndStart(); 

        /* ------------------- JavaScript End ------------------- */
    </script>
</body>
</html>
