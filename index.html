<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AI è£ç½®ç«¯æ‰‹å‹¢åˆ‡æ°´æœ (MoveNet)</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.13.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.0.0/dist/pose-detection.min.js"></script>
    
    <style>
        /* (CSS ä¿æŒä¸è®Š) */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #000;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            max-width: 600px;
            max-height: 900px;
            margin: auto;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #video, #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover; /* è®“å½±ç‰‡å¡«æ»¿å®¹å™¨ */
        }

        #video {
            opacity: 0.2;
            transform: scaleX(-1);
        }

        #canvas {
            z-index: 10;
        }

        #status {
            position: absolute;
            top: 10px;
            width: 80%;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.9);
            color: #333;
            border-radius: 8px;
            font-weight: bold;
            z-index: 20;
            text-align: center;
        }

        #start-btn {
            position: absolute;
            bottom: 50px;
            background-color: #e91e63;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 30px;
            font-size: 1.2em;
            cursor: pointer;
            z-index: 30;
            transition: background-color 0.3s;
        }

        #start-btn:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <video id="video" autoplay muted playsinline></video>
        <canvas id="canvas"></canvas>

        <div id="status">æ­£åœ¨è¼‰å…¥ AI æ¨¡å‹...</div>
        <button id="start-btn" disabled>ç­‰å¾…æ¨¡å‹è¼‰å…¥...</button>
    </div>

    <script>
        /* ------------------- JavaScript Start ------------------- */

        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const statusDiv = document.getElementById('status');
        const startBtn = document.getElementById('start-btn');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('game-container'); // å–å¾—å®¹å™¨å…ƒç´ 
        
        let detector = null;
        let animationFrameId = null;
        let isRunning = false;
        
        // **æ–°å¢**ï¼šç”¨æ–¼å„²å­˜è¨ˆç®—å¾Œçš„ç¸®æ”¾å’Œå¹³ç§»åƒæ•¸
        let scaleX = 1;
        let scaleY = 1;
        let offsetX = 0;
        let offsetY = 0;

        // åµæ¸¬é»æ­·å²ï¼ˆç”¨æ–¼åˆ¤æ–·æ‰‹éƒ¨ç§»å‹•è»Œè·¡ï¼‰
        const handHistory = { left: [], right: [] };
        const HISTORY_LENGTH = 5;

        // æ°´æœé¡åˆ¥å’Œç‹€æ…‹
        const FRUITS = ['ğŸ', 'ğŸ‰', 'ğŸ¥', 'ğŸ‹', 'ğŸ‡'];
        let activeFruits = [];
        let score = 0;

        // éŠæˆ²åƒæ•¸
        const FRUIT_SIZE = 50;
        let lastLaunchTime = 0;
        const LAUNCH_INTERVAL = 1500;

        // --- 1. æ ¸å¿ƒæ¨¡å‹å’Œå•Ÿå‹• ---

        async function loadModelsAndStart() {
             // ... (loadModelsAndStart å…§å®¹ä¿æŒä¸è®Š) ...
            try {
                const detectorConfig = {
                    modelType: poseDetection.SupportedModels.MoveNet,
                    detectorParams: {
                        modelType: poseDetection.MoveNetType.SinglePoseLightning,
                        enableSmoothing: true
                    }
                };
                
                detector = await poseDetection.createDetector(poseDetection.SupportedModels.MoveNet, detectorConfig);

                statusDiv.innerHTML = "âœ… æ¨¡å‹è¼‰å…¥å®Œæˆï¼é»æ“Šé–‹å§‹éŠæˆ²ã€‚";
                statusDiv.style.backgroundColor = 'rgba(0, 128, 0, 0.8)';
                startBtn.disabled = false;
                startBtn.textContent = "é–‹å§‹åˆ‡æ°´æœï¼";
                
                startCamera();

            } catch (error) {
                console.error("è¼‰å…¥æ¨¡å‹å¤±æ•—:", error);
                statusDiv.innerHTML = `âŒ æ¨¡å‹è¼‰å…¥å¤±æ•—ï¼ŒéŒ¯èª¤: ${error.message}`;
                statusDiv.style.backgroundColor = 'rgba(255, 0, 0, 0.8)';
            }
        }
        
        async function startCamera() {
             // ... (startCamera å…§å®¹ä¿æŒä¸è®Š) ...
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        facingMode: 'user', 
                        // é€™è£¡ä½¿ç”¨è¼ƒä½çš„ç†æƒ³è§£æåº¦ï¼Œä»¥é¿å…æ‰‹æ©Ÿæ•ˆèƒ½å•é¡Œ
                        width: { ideal: 480 }, 
                        height: { ideal: 640 } 
                    } 
                });
                video.srcObject = stream;
            } catch (err) {
                console.error("ç„¡æ³•å–å¾—ç›¸æ©Ÿæ¬Šé™:", err);
                statusDiv.innerHTML = "âŒ ç„¡æ³•å•Ÿå‹•ç›¸æ©Ÿï¼Œè«‹æª¢æŸ¥æ¬Šé™ã€‚";
            }
        }

        // å½±ç‰‡è¼‰å…¥å®Œæˆå¾Œï¼Œ**ä¿®æ­£åº§æ¨™å°é½Šè¨ˆç®—**
        video.addEventListener('loadeddata', () => {
            const videoRatio = video.videoWidth / video.videoHeight;
            const containerRatio = container.clientWidth / container.clientHeight;

            // èª¿æ•´ Canvas å°ºå¯¸ä»¥åŒ¹é…å®¹å™¨é¡¯ç¤ºå°ºå¯¸
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;

            // ç”±æ–¼ object-fit: coverï¼Œéœ€è¦è¨ˆç®—å¯¦éš›çš„ç¸®æ”¾æ¯”ä¾‹å’Œåç§»é‡
            if (videoRatio > containerRatio) {
                // å½±ç‰‡è¼ƒå¯¬ï¼Œå‚ç›´æ–¹å‘è¢«è£å‰ª (å·¦å³æœ‰é»‘é‚Šï¼Œä½† 'cover' æœƒè®“é»‘é‚Šæ¶ˆå¤±ï¼Œå¯¦éš›æ˜¯ä¸Šä¸‹è¢«å¡«æ»¿)
                scaleY = canvas.height / video.videoHeight;
                scaleX = scaleY; // X è»¸ä¹Ÿä½¿ç”¨ Y è»¸çš„ç¸®æ”¾æ¯”
                offsetX = (canvas.width - video.videoWidth * scaleX) / 2;
                offsetY = 0;
            } else {
                // å½±ç‰‡è¼ƒé«˜ï¼Œæ°´å¹³æ–¹å‘è¢«è£å‰ª (ä¸Šä¸‹æœ‰é»‘é‚Šï¼Œä½† 'cover' æœƒè®“é»‘é‚Šæ¶ˆå¤±ï¼Œå¯¦éš›æ˜¯å·¦å³è¢«å¡«æ»¿)
                scaleX = canvas.width / video.videoWidth;
                scaleY = scaleX; // Y è»¸ä¹Ÿä½¿ç”¨ X è»¸çš„ç¸®æ”¾æ¯”
                offsetX = 0;
                offsetY = (canvas.height - video.videoHeight * scaleY) / 2;
            }
        });


        // --- 2. æ°´æœç‰©ä»¶èˆ‡ç”Ÿæˆ (ä¿æŒä¸è®Š) ---
        class Fruit {
            // ... (Fruit Class å…§å®¹ä¿æŒä¸è®Š) ...
            constructor(emoji) {
                this.emoji = emoji;
                this.x = Math.random() * (canvas.width * 0.8) + (canvas.width * 0.1);
                this.y = canvas.height + FRUIT_SIZE;
                this.radius = FRUIT_SIZE / 2;
                this.velocity = { 
                    x: (Math.random() - 0.5) * 5,
                    y: - (Math.random() * 10 + 20)
                };
                this.gravity = 0.9;
                this.isCut = false;
                this.cutAngle = 0;
            }

            update() {
                this.velocity.y += this.gravity;
                this.x += this.velocity.x;
                this.y += this.velocity.y;
            }

            draw() {
                ctx.font = `${FRUIT_SIZE}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                if (this.isCut) {
                    const halfText = this.emoji.substring(0, 1);
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.cutAngle);
                    ctx.fillText(halfText, -this.radius / 2, 0); 
                    ctx.fillText(halfText, this.radius / 2, 0);
                    ctx.restore();
                } else {
                    ctx.fillText(this.emoji, this.x, this.y);
                }
            }
        }

        function launchFruit(timestamp) {
            if (timestamp - lastLaunchTime > LAUNCH_INTERVAL) {
                const randomEmoji = FRUITS[Math.floor(Math.random() * FRUITS.length)];
                activeFruits.push(new Fruit(randomEmoji));
                lastLaunchTime = timestamp;
            }
        }


        // --- 3. AI åµæ¸¬èˆ‡åˆ‡ä¸­é‚è¼¯ ---

        function checkCollision(history, fruit) {
            // ... (checkCollision å…§å®¹ä¿æŒä¸è®Š) ...
            if (fruit.isCut) return false;
            if (history.length < 2) return false;

            const p1 = history[history.length - 1];
            // const p2 = history[history.length - 2]; // p2 ä¸ç”¨æ–¼è·é›¢è¨ˆç®—ï¼Œä½†ç”¨æ–¼ cutAngle

            const dist = Math.hypot(p1.x - fruit.x, p1.y - fruit.y);

            if (dist < fruit.radius) {
                fruit.isCut = true;
                // æ³¨æ„ï¼šé€™è£¡ cutAngle æ‡‰è©²ä½¿ç”¨ p2ï¼Œä½†å› ç‚º p2 å¯èƒ½ä¸æº–ç¢ºï¼Œæš«æ™‚ç¶­æŒåŸç‹€
                // fruit.cutAngle = Math.atan2(p2.y - p1.y, p2.x - p1.x); 
                fruit.cutAngle = Math.random() * Math.PI; // ç°¡åŒ–åˆ‡å£è§’åº¦
                
                score++;
                statusDiv.innerHTML = `å¾—åˆ†ï¼š${score} | æˆåŠŸåˆ‡ä¸­ ${fruit.emoji}`;
                return true;
            }
            return false;
        }

        async function detectAndGameLoop(timestamp) {
            if (!detector || video.paused || video.ended || !isRunning) {
                cancelAnimationFrame(animationFrameId);
                return;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 1. åŸ·è¡Œ AI åµæ¸¬
            const poses = await detector.estimatePoses(video, {
                flipHorizontal: true // ç¢ºä¿èˆ‡ video CSS é¡åƒåŒ¹é…
            });

            if (poses && poses.length > 0) {
                const pose = poses[0];
                const keypoints = pose.keypoints;
                
                const leftWrist = keypoints[9];
                const rightWrist = keypoints[10];
                
                // **ä¿®æ­£å¾Œçš„æ˜ å°„å‡½å¼**
                const mapKeypoint = (kp) => {
                    // æ‡‰ç”¨ç¸®æ”¾å’Œå¹³ç§»ï¼Œä»¥æº–ç¢ºå°é½Š Canvas é¡¯ç¤º
                    return {
                        x: kp.x * scaleX + offsetX,
                        y: kp.y * scaleY + offsetY
                    };
                };

                // æ›´æ–°æ‰‹éƒ¨è»Œè·¡
                if (leftWrist.score > 0.6) {
                    handHistory.left.push(mapKeypoint(leftWrist));
                    if (handHistory.left.length > HISTORY_LENGTH) handHistory.left.shift();
                }
                if (rightWrist.score > 0.6) {
                    handHistory.right.push(mapKeypoint(rightWrist));
                    if (handHistory.right.length > HISTORY_LENGTH) handHistory.right.shift();
                }
                
                // ç¹ªè£½æ‰‹éƒ¨è»Œè·¡
                [handHistory.left, handHistory.right].forEach(history => {
                    ctx.strokeStyle = 'cyan';
                    ctx.lineWidth = 8;
                    ctx.beginPath();
                    history.forEach((p, index) => {
                        if (index === 0) {
                            ctx.moveTo(p.x, p.y);
                        } else {
                            ctx.lineTo(p.x, p.y);
                        }
                    });
                    ctx.stroke();
                });
                
                // 2. éŠæˆ²é‚è¼¯ï¼šåˆ‡ä¸­åˆ¤æ–· (ä¿æŒä¸è®Š)
                activeFruits.forEach(fruit => {
                    if (!fruit.isCut) {
                        checkCollision(handHistory.left, fruit) || checkCollision(handHistory.right, fruit);
                    }
                });

            }

            // 3. æ›´æ–°èˆ‡ç¹ªè£½æ°´æœ (ä¿æŒä¸è®Š)
            launchFruit(timestamp);

            activeFruits.forEach(fruit => {
                fruit.update();
                fruit.draw();
            });

            activeFruits = activeFruits.filter(fruit => fruit.y > -FRUIT_SIZE);

            animationFrameId = requestAnimationFrame(detectAndGameLoop);
        }

        // --- 4. äº‹ä»¶ç›£è½å™¨èˆ‡åˆå§‹åŒ– (ä¿æŒä¸è®Š) ---

        startBtn.addEventListener('click', () => {
             if (!isRunning) {
                 isRunning = true;
                 startBtn.textContent = "éŠæˆ²é€²è¡Œä¸­...";
                 startBtn.disabled = true;
                 score = 0;
                 activeFruits = [];
                 lastLaunchTime = 0;
                 statusDiv.innerHTML = `å¾—åˆ†ï¼š0 | è«‹æ®å‹•æ‚¨çš„æ‰‹ï¼`;
                 detectAndGameLoop(performance.now());
             }
        });
        
        loadModelsAndStart(); 

        /* ------------------- JavaScript End ------------------- */
    </script>
</body>
</html>
