<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AI è£ç½®ç«¯æ‰‹å‹¢åˆ‡æ°´æœ (MoveNet)</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.13.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.0.0/dist/pose-detection.min.js"></script>
    
    <style>
        /* ------------------- CSS Start ------------------- */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #000; /* éŠæˆ²èƒŒæ™¯é€šå¸¸æ˜¯é»‘è‰² */
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow: hidden; /* é¿å…æ»¾å‹•æ¢ */
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            max-width: 600px;
            max-height: 900px;
            margin: auto;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #video, #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #video {
            opacity: 0.2; /* å°‡ç›¸æ©Ÿç•«é¢èª¿æš—ï¼Œä½œç‚ºèƒŒæ™¯ */
            transform: scaleX(-1); /* å‰é¡é ­é è¨­é¡åƒ */
        }

        #canvas {
            z-index: 10;
        }

        #status {
            position: absolute;
            top: 10px;
            width: 80%;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.9);
            color: #333;
            border-radius: 8px;
            font-weight: bold;
            z-index: 20;
            text-align: center;
        }

        #start-btn {
            position: absolute;
            bottom: 50px;
            background-color: #e91e63;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 30px;
            font-size: 1.2em;
            cursor: pointer;
            z-index: 30;
            transition: background-color 0.3s;
        }

        #start-btn:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }

        /* ------------------- CSS End ------------------- */
    </style>
</head>
<body>

    <div id="game-container">
        <video id="video" autoplay muted playsinline></video>
        <canvas id="canvas"></canvas>

        <div id="status">æ­£åœ¨è¼‰å…¥ AI æ¨¡å‹...</div>
        <button id="start-btn" disabled>ç­‰å¾…æ¨¡å‹è¼‰å…¥...</button>
    </div>

    <script>
        /* ------------------- JavaScript Start ------------------- */

        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const statusDiv = document.getElementById('status');
        const startBtn = document.getElementById('start-btn');
        const ctx = canvas.getContext('2d');
        
        let detector = null;
        let animationFrameId = null;
        let isRunning = false;
        
        // åµæ¸¬é»æ­·å²ï¼ˆç”¨æ–¼åˆ¤æ–·æ‰‹éƒ¨ç§»å‹•è»Œè·¡ï¼‰
        const handHistory = {
            left: [],
            right: []
        };
        const HISTORY_LENGTH = 5; // ç´€éŒ„æœ€è¿‘ 5 å¹€çš„è»Œè·¡

        // æ°´æœé¡åˆ¥å’Œç‹€æ…‹
        const FRUITS = ['ğŸ', 'ğŸ‰', 'ğŸ¥', 'ğŸ‹', 'ğŸ‡'];
        let activeFruits = [];
        let score = 0;

        // éŠæˆ²åƒæ•¸
        const DETECT_INTERVAL_MS = 50; // æ¯ 50ms åµæ¸¬ä¸€æ¬¡
        const FRUIT_SIZE = 50;
        let lastLaunchTime = 0;
        const LAUNCH_INTERVAL = 1500; // æ¯ 1.5 ç§’ç™¼å°„ä¸€å€‹æ°´æœ

        // --- 1. æ ¸å¿ƒæ¨¡å‹å’Œå•Ÿå‹• ---

        async function loadModelsAndStart() {
            try {
                // è¼‰å…¥ MoveNet æ¨¡å‹ (è¼•é‡ç´š SinglePose.Lightning)
                const detectorConfig = {
                    modelType: poseDetection.SupportedModels.MoveNet,
                    detectorParams: {
                        modelType: poseDetection.MoveNetType.SinglePoseLightning,
                        enableSmoothing: true
                    }
                };
                
                detector = await poseDetection.createDetector(poseDetection.SupportedModels.MoveNet, detectorConfig);

                statusDiv.innerHTML = "âœ… æ¨¡å‹è¼‰å…¥å®Œæˆï¼é»æ“Šé–‹å§‹éŠæˆ²ã€‚";
                statusDiv.style.backgroundColor = 'rgba(0, 128, 0, 0.8)';
                startBtn.disabled = false;
                startBtn.textContent = "é–‹å§‹åˆ‡æ°´æœï¼";
                
                // å•Ÿå‹•ç›¸æ©Ÿ (ä½¿ç”¨å‰ç½®é¡é ­ 'user')
                startCamera();

            } catch (error) {
                console.error("è¼‰å…¥æ¨¡å‹å¤±æ•—:", error);
                statusDiv.innerHTML = `âŒ æ¨¡å‹è¼‰å…¥å¤±æ•—ï¼ŒéŒ¯èª¤: ${error.message}`;
                statusDiv.style.backgroundColor = 'rgba(255, 0, 0, 0.8)';
            }
        }
        
        // å•Ÿå‹•ç›¸æ©Ÿ (ä½¿ç”¨å‰ç½®é¡é ­)
        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        facingMode: 'user', 
                        width: { ideal: 400 }, 
                        height: { ideal: 600 } 
                    } 
                });
                video.srcObject = stream;
            } catch (err) {
                console.error("ç„¡æ³•å–å¾—ç›¸æ©Ÿæ¬Šé™:", err);
                statusDiv.innerHTML = "âŒ ç„¡æ³•å•Ÿå‹•ç›¸æ©Ÿï¼Œè«‹æª¢æŸ¥æ¬Šé™ã€‚";
            }
        }

        // å½±ç‰‡è¼‰å…¥å®Œæˆå¾Œï¼Œèª¿æ•´ Canvas å¤§å°
        video.addEventListener('loadeddata', () => {
            // ç¢ºä¿ Canvas å°ºå¯¸èˆ‡ Video å®¹å™¨å°ºå¯¸ä¸€è‡´
            const container = document.getElementById('game-container');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        });


        // --- 2. æ°´æœç‰©ä»¶èˆ‡ç”Ÿæˆ ---

        class Fruit {
            constructor(emoji) {
                this.emoji = emoji;
                this.x = Math.random() * (canvas.width * 0.8) + (canvas.width * 0.1);
                this.y = canvas.height + FRUIT_SIZE; // å¾è¢å¹•åº•éƒ¨ç™¼å°„
                this.radius = FRUIT_SIZE / 2;
                this.velocity = { 
                    x: (Math.random() - 0.5) * 5, // éš¨æ©Ÿæ°´å¹³é€Ÿåº¦
                    y: - (Math.random() * 10 + 20) // å‘ä¸Šç™¼å°„çš„åˆé€Ÿåº¦
                };
                this.gravity = 0.9;
                this.isCut = false;
                this.cutAngle = 0;
            }

            update() {
                this.velocity.y += this.gravity;
                this.x += this.velocity.x;
                this.y += this.velocity.y;
            }

            draw() {
                ctx.font = `${FRUIT_SIZE}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                if (this.isCut) {
                    // ç¹ªè£½è¢«åˆ‡é–‹çš„å…©åŠ (ç°¡åŒ–è™•ç†)
                    const halfText = this.emoji.substring(0, 1);
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.cutAngle);
                    
                    // ç¹ªè£½å·¦åŠé‚Š
                    ctx.fillText(halfText, -this.radius / 2, 0); 
                    // ç¹ªè£½å³åŠé‚Š
                    ctx.fillText(halfText, this.radius / 2, 0);

                    ctx.restore();
                } else {
                    ctx.fillText(this.emoji, this.x, this.y);
                }

                // ç¹ªè£½ç”¨æ–¼åµæ¸¬çš„åœ“å½¢é‚Šç•Œ (é™¤éŒ¯ç”¨ï¼Œæ­£å¼é‹è¡Œæ™‚å¯ç§»é™¤)
                // ctx.beginPath();
                // ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
                // ctx.strokeStyle = 'yellow';
                // ctx.stroke();
            }
        }

        function launchFruit(timestamp) {
            if (timestamp - lastLaunchTime > LAUNCH_INTERVAL) {
                const randomEmoji = FRUITS[Math.floor(Math.random() * FRUITS.length)];
                activeFruits.push(new Fruit(randomEmoji));
                lastLaunchTime = timestamp;
            }
        }


        // --- 3. AI åµæ¸¬èˆ‡åˆ‡ä¸­é‚è¼¯ ---

        function checkCollision(history, fruit) {
            if (fruit.isCut) return false;

            // å¦‚æœæ­·å²è»Œè·¡ä¸è¶³ï¼Œä¸é€²è¡Œåˆ¤æ–·
            if (history.length < 2) return false;

            // å–æœ€è¿‘å…©é»ä½œç‚ºåˆ‡ç·š
            const p1 = history[history.length - 1]; // ç•¶å‰æ‰‹éƒ¨ä½ç½®
            const p2 = history[history.length - 2]; // ä¸Šä¸€å¹€æ‰‹éƒ¨ä½ç½®

            // åˆ¤æ–·ç·šæ®µ P1P2 æ˜¯å¦èˆ‡æ°´æœåœ“å½¢ç›¸äº¤
            // ä½¿ç”¨ç°¡åŒ–çš„åœ“å½¢èˆ‡ç·šæ®µç¢°æ’æª¢æ¸¬ (æ­¤è™•ç‚ºæœ€ç°¡åŒ–ç‰ˆæœ¬ï¼šåˆ¤æ–·ä¸­å¿ƒé»è·é›¢)
            
            const dist = Math.hypot(p1.x - fruit.x, p1.y - fruit.y);

            if (dist < fruit.radius) {
                fruit.isCut = true;
                fruit.cutAngle = Math.atan2(p2.y - p1.y, p2.x - p1.x); // æ ¹æ“šåˆ‡ç·šæ–¹å‘çµ¦äºˆåˆ‡å£è§’åº¦
                
                // å¢åŠ å¾—åˆ†ä¸¦æ›´æ–°ç‹€æ…‹
                score++;
                statusDiv.innerHTML = `å¾—åˆ†ï¼š${score} | æˆåŠŸåˆ‡ä¸­ ${fruit.emoji}`;
                return true;
            }
            return false;
        }

        async function detectAndGameLoop(timestamp) {
            if (!detector || video.paused || video.ended || !isRunning) {
                cancelAnimationFrame(animationFrameId);
                return;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height); // æ¸…ç©ºç•«å¸ƒ

            // 1. åŸ·è¡Œ AI åµæ¸¬
            const poses = await detector.estimatePoses(video, {
                // ç¢ºä¿èˆ‡ video CSS é¡åƒåŒ¹é…
                flipHorizontal: true 
            });

            if (poses && poses.length > 0) {
                const pose = poses[0];
                const keypoints = pose.keypoints;
                
                // ç²å–å·¦å³æ‰‹è…•çš„é—œéµé»
                const leftWrist = keypoints[9];
                const rightWrist = keypoints[10];
                
                // æ˜ å°„é—œéµé»åº§æ¨™åˆ° Canvas åº§æ¨™ (MoveNet è¼¸å‡ºçš„æ˜¯æ­£è¦åŒ–åº§æ¨™ï¼Œéœ€è½‰æ›)
                const mapKeypoint = (kp) => {
                    // X è»¸éœ€è¦åè½‰ï¼Œå› ç‚º MoveNet åµæ¸¬çš„æ˜¯åŸå§‹è¦–è¨Šå¹€ï¼Œè€Œæˆ‘å€‘åœ¨ CSS ä¸Šåšäº†é¡åƒ
                    // ä½†å› ç‚ºå‰é¢ flipHorizontal=true å·²ç¶“ç¿»è½‰åº§æ¨™ï¼Œæ‰€ä»¥é€™è£¡ç›´æ¥ä½¿ç”¨å³å¯
                    return {
                        x: kp.x * (canvas.width / video.videoWidth),
                        y: kp.y * (canvas.height / video.videoHeight)
                    };
                };

                // æ›´æ–°æ‰‹éƒ¨è»Œè·¡
                if (leftWrist.score > 0.6) {
                    handHistory.left.push(mapKeypoint(leftWrist));
                    if (handHistory.left.length > HISTORY_LENGTH) handHistory.left.shift();
                }
                if (rightWrist.score > 0.6) {
                    handHistory.right.push(mapKeypoint(rightWrist));
                    if (handHistory.right.length > HISTORY_LENGTH) handHistory.right.shift();
                }
                
                // ç¹ªè£½æ‰‹éƒ¨è»Œè·¡ (é™¤éŒ¯èˆ‡è¦–è¦ºæ•ˆæœ)
                [handHistory.left, handHistory.right].forEach(history => {
                    ctx.strokeStyle = 'cyan';
                    ctx.lineWidth = 8;
                    ctx.beginPath();
                    history.forEach((p, index) => {
                        if (index === 0) {
                            ctx.moveTo(p.x, p.y);
                        } else {
                            ctx.lineTo(p.x, p.y);
                        }
                    });
                    ctx.stroke();
                });
                
                // 2. éŠæˆ²é‚è¼¯ï¼šåˆ‡ä¸­åˆ¤æ–·
                
                // æª¢æŸ¥æ‰€æœ‰æ´»å‹•ä¸­çš„æ°´æœ
                activeFruits.forEach(fruit => {
                    // æª¢æŸ¥å·¦æ‰‹æˆ–å³æ‰‹æ˜¯å¦åˆ‡ä¸­
                    if (!fruit.isCut) {
                        checkCollision(handHistory.left, fruit) || checkCollision(handHistory.right, fruit);
                    }
                });

            }

            // 3. æ›´æ–°èˆ‡ç¹ªè£½æ°´æœ
            
            // ç™¼å°„æ–°æ°´æœ
            launchFruit(timestamp);

            activeFruits.forEach(fruit => {
                fruit.update();
                fruit.draw();
            });

            // æ¸…ç†å·²é£›å‡ºè¢å¹•çš„æ°´æœ
            activeFruits = activeFruits.filter(fruit => fruit.y > -FRUIT_SIZE);

            animationFrameId = requestAnimationFrame(detectAndGameLoop);
        }

        // --- 4. äº‹ä»¶ç›£è½å™¨èˆ‡åˆå§‹åŒ– ---

        startBtn.addEventListener('click', () => {
             if (!isRunning) {
                 isRunning = true;
                 startBtn.textContent = "éŠæˆ²é€²è¡Œä¸­...";
                 startBtn.disabled = true; // é–‹å§‹å¾Œç¦ç”¨æŒ‰éˆ•
                 // é‡ç½®åˆ†æ•¸å’Œæ°´æœ
                 score = 0;
                 activeFruits = [];
                 lastLaunchTime = 0;
                 statusDiv.innerHTML = `å¾—åˆ†ï¼š0 | è«‹æ®å‹•æ‚¨çš„æ‰‹ï¼`;

                 // å•Ÿå‹•éŠæˆ²å¾ªç’°
                 detectAndGameLoop(performance.now());
             }
        });
        
        // åˆå§‹åŒ–ï¼šè¼‰å…¥æ¨¡å‹
        loadModelsAndStart(); 

        /* ------------------- JavaScript End ------------------- */
    </script>
</body>
</html>
